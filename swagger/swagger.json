{
  "swagger" : "2.0",
  "info" : {
    "description" : "QuantiModo makes it easy to retrieve normalized user data from a wide array of devices and applications. [Learn about QuantiModo](https://quantimo.do), check out our [docs](https://github.com/QuantiModo/docs) or contact us at [help.quantimo.do](https://help.quantimo.do).\n",
    "version" : "5.8.5",
    "title" : "QuantiModo",
    "termsOfService" : "https://quantimo.do/tos/",
    "contact" : {
      "name" : "info@quantimo.do"
    }
  },
  "host" : "app.quantimo.do",
  "basePath" : "/api",
  "schemes" : [ "https" ],
  "consumes" : [ "application/json" ],
  "produces" : [ "application/json" ],
  "paths" : {
    "/v1/integration.js" : {
      "get" : {
        "tags" : [ "connectors" ],
        "summary" : "Get embeddable connect javascript",
        "description" : "Get embeddable connect javascript. Usage:\n  - Embedding in applications with popups for 3rd-party authentication\nwindows.\n    Use `qmSetupInPopup` function after connecting `connect.js`.\n  - Embedding in applications with popups for 3rd-party authentication\nwindows.\n    Requires a selector to block. It will be embedded in this block.\n    Use `qmSetupOnPage` function after connecting `connect.js`.\n  - Embedding in mobile applications without popups for 3rd-party\nauthentication.\n    Use `qmSetupOnMobile` function after connecting `connect.js`.\n    If using in a Cordova application call  `qmSetupOnIonic` function after connecting `connect.js`.",
        "produces" : [ "application/x-javascript" ],
        "parameters" : [ {
          "name" : "clientId",
          "in" : "query",
          "description" : "Your app's client id",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Embeddable connect javascript was returned"
          }
        }
      }
    },
    "/v1/connect/mobile" : {
      "get" : {
        "tags" : [ "connectors" ],
        "summary" : "Mobile connect page",
        "description" : "This page is designed to be opened in a webview.  Instead of using popup authentication boxes, it uses redirection. You can include the user's access_token as a URL parameter like https://app.quantimo.do/api/v1/connect/mobile?access_token=123",
        "produces" : [ "text/html" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User OAuth access token",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "Mobile connect page was returned"
          },
          "401" : {
            "description" : "User token is missing"
          },
          "403" : {
            "description" : "User token is incorrect"
          }
        }
      }
    },
    "/v1/connectors/list" : {
      "get" : {
        "tags" : [ "connectors" ],
        "summary" : "List of Connectors",
        "description" : "A connector pulls data from other data providers using their API or a screenscraper. Returns a list of all available connectors and information about them such as their id, name, whether the user has provided access, logo url, connection instructions, and the update history.",
        "produces" : [ "application/json" ],
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Connector"
              }
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/connectors/{connectorName}/connect" : {
      "get" : {
        "tags" : [ "connectors" ],
        "summary" : "Obtain a token from 3rd party data source",
        "description" : "Attempt to obtain a token from the data provider, store it in the database. With this, the connector to continue to obtain new user data until the token is revoked.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "connectorName",
          "in" : "path",
          "description" : "Lowercase system name of the source application or device. Get a list of available connectors from the /v1/connectors/list endpoint.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation"
          },
          "401" : {
            "description" : "Not Authenticated"
          },
          "404" : {
            "description" : "Method not found. Could not execute the requested method."
          },
          "500" : {
            "description" : "Error during update. Unsupported response from update()."
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/connectors/{connectorName}/connectParameter" : {
      "get" : {
        "tags" : [ "connectors" ],
        "summary" : "Connect Parameter",
        "description" : "Returns instructions that describe what parameters and endpoint to use to connect to the given data provider.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "connectorName",
          "in" : "path",
          "description" : "Lowercase system name of the source application or device. Get a list of available connectors from the /v1/connectors/list endpoint.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "defaultValue",
          "in" : "query",
          "description" : "Default parameter value",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "displayName",
          "in" : "query",
          "description" : "Name of the parameter that is user visible in the form",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "key",
          "in" : "query",
          "description" : "Name of the property that the user has to enter such as username or password Connector (used in HTTP request)",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "placeholder",
          "in" : "query",
          "description" : "Placeholder hint value for the parameter input tag.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "type",
          "in" : "query",
          "description" : "Type of input field such as those found here http://www.w3schools.com/tags/tag_input.asp",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "usePopup",
          "in" : "query",
          "description" : "Should use popup when enabling connector",
          "required" : true,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "schema" : {
              "$ref" : "#/definitions/ConnectorInstruction"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          },
          "404" : {
            "description" : "Method not found. Could not execute the requested method."
          },
          "500" : {
            "description" : "Error during update. Unsupported response from update()."
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/connectors/{connectorName}/connectInstructions" : {
      "get" : {
        "tags" : [ "connectors" ],
        "summary" : "Connection Instructions",
        "description" : "Returns instructions that describe what parameters and endpoint to use to connect to the given data provider.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "connectorName",
          "in" : "path",
          "description" : "Lowercase system name of the source application or device. Get a list of available connectors from the /v1/connectors/list endpoint.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "parameters",
          "in" : "query",
          "description" : "JSON Array of Parameters for the request to enable connector.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "url",
          "in" : "query",
          "description" : "URL which should be used to enable the connector.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "usePopup",
          "in" : "query",
          "description" : "Should use popup when enabling connector",
          "required" : true,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation"
          },
          "401" : {
            "description" : "Not Authenticated"
          },
          "404" : {
            "description" : "Method not found. Could not execute the requested method."
          },
          "500" : {
            "description" : "Error during update. Unsupported response from update()."
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/connectors/{connectorName}/disconnect" : {
      "get" : {
        "tags" : [ "connectors" ],
        "summary" : "Delete stored connection info",
        "description" : "The disconnect method deletes any stored tokens or connection information from the connectors database.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "connectorName",
          "in" : "path",
          "description" : "Lowercase system name of the source application or device. Get a list of available connectors from the /v1/connectors/list endpoint.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation"
          },
          "401" : {
            "description" : "Not Authenticated"
          },
          "404" : {
            "description" : "Method not found. Could not execute the requested method."
          },
          "500" : {
            "description" : "Error during update. Unsupported response from update()."
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/connectors/{connectorName}/info" : {
      "get" : {
        "tags" : [ "connectors" ],
        "summary" : "Get connector info for user",
        "description" : "Returns information about the connector such as the connector id, whether or not is connected for this user (i.e. we have a token or credentials), and its update history for the user.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "connectorName",
          "in" : "path",
          "description" : "Lowercase system name of the source application or device. Get a list of available connectors from the /v1/connectors/list endpoint.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "schema" : {
              "$ref" : "#/definitions/ConnectorInfo"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          },
          "404" : {
            "description" : "Method not found. Could not execute the requested method."
          },
          "500" : {
            "description" : "Error during update. Please contact info@quantimo.do."
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/connectors/{connectorName}/update" : {
      "get" : {
        "tags" : [ "connectors" ],
        "summary" : "Sync with data source",
        "description" : "The update method tells the QM Connector Framework to check with the data provider (such as Fitbit or MyFitnessPal) and retrieve any new measurements available.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "connectorName",
          "in" : "path",
          "description" : "Lowercase system name of the source application or device",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Connection Successful"
          },
          "401" : {
            "description" : "Not Authenticated"
          },
          "404" : {
            "description" : "Method not found. Could not execute the requested method."
          },
          "500" : {
            "description" : "Error during update. Unsupported response from update()."
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/correlations" : {
      "get" : {
        "tags" : [ "correlations" ],
        "summary" : "Get correlations",
        "description" : "Get correlations based on data from a single user.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "effect",
          "in" : "query",
          "description" : "Variable name of the effect variable for which the user desires correlations",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "cause",
          "in" : "query",
          "description" : "Variable name of the cause variable for which the user desires correlations",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "correlationCoefficient",
          "in" : "query",
          "description" : "Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "onsetDelay",
          "in" : "query",
          "description" : "The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the “onset delay”. For example, the “onset delay” between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "durationOfAction",
          "in" : "query",
          "description" : "The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "updatedAt",
          "in" : "query",
          "description" : "The time that this measurement was last updated in the UTC format \"YYYY-MM-DDThh:mm:ss\".  Generally, you'll be retrieving new or updated user data. To avoid unnecessary API calls, you'll want to store your last refresh time locally. Then whenever you make a request to get new data, you should limit the returned results to those updated since your last refresh by appending append `?updatedAt=(ge)2013-01-D01T01:01:01 to your request.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "offset",
          "in" : "query",
          "description" : "Since the maximum limit is 200 records, to get more than that you'll have to make multiple API calls and page through the results. To retrieve all the data, you can iterate through data by using the `limit` and `offset` query parameters.  For example, if you want to retrieve data from 61-80 then you can use a query with the following parameters, `imit=20&offset=60`.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sort by given field. If the field is prefixed with `-, it will sort in descending order.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "outcomesOfInterest",
          "in" : "query",
          "description" : "Only include correlations for which the effect is an outcome of interest for the user",
          "required" : false,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Correlation"
              }
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/aggregatedCorrelations" : {
      "get" : {
        "tags" : [ "correlations" ],
        "summary" : "Get aggregated correlations",
        "description" : "Get correlations based on the anonymized aggregate data from all QuantiModo users.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "effect",
          "in" : "query",
          "description" : "Variable name of the effect variable for which the user desires correlations",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "cause",
          "in" : "query",
          "description" : "Variable name of the cause variable for which the user desires correlations",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "correlationCoefficient",
          "in" : "query",
          "description" : "Pearson correlation coefficient between cause and effect after lagging by onset delay and grouping by duration of action",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "onsetDelay",
          "in" : "query",
          "description" : "The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the “onset delay”. For example, the “onset delay” between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "durationOfAction",
          "in" : "query",
          "description" : "The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "updatedAt",
          "in" : "query",
          "description" : "The time that this measurement was last updated in the UTC format \"YYYY-MM-DDThh:mm:ss\".  Generally, you'll be retrieving new or updated user data. To avoid unnecessary API calls, you'll want to store your last refresh time locally. Then whenever you make a request to get new data, you should limit the returned results to those updated since your last refresh by appending append `?updatedAt=(ge)2013-01-D01T01:01:01 to your request.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "offset",
          "in" : "query",
          "description" : "Since the maximum limit is 200 records, to get more than that you'll have to make multiple API calls and page through the results. To retrieve all the data, you can iterate through data by using the `limit` and `offset` query parameters.  For example, if you want to retrieve data from 61-80 then you can use a query with the following parameters, `imit=20&offset=60`.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sort by given field. If the field is prefixed with `-, it will sort in descending order.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "outcomesOfInterest",
          "in" : "query",
          "description" : "Only include correlations for which the effect is an outcome of interest for the user",
          "required" : false,
          "type" : "boolean"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Correlation"
              }
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      },
      "post" : {
        "tags" : [ "correlations" ],
        "summary" : "Store or Update a Correlation",
        "description" : "Add correlation",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Provides correlation data",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PostCorrelation"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation"
          },
          "400" : {
            "description" : "Bad request",
            "schema" : {
              "$ref" : "#/definitions/JsonErrorResponse"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/measurements" : {
      "get" : {
        "tags" : [ "measurements" ],
        "summary" : "Get measurements for this user",
        "description" : "Measurements are any value that can be recorded like daily steps, a mood rating, or apples eaten. Supported filter parameters:<ul><li><b>value</b> - Value of measurement</li><li><b>updatedAt</b> - The time that this measurement was created or last updated in the UTC format \"YYYY-MM-DDThh:mm:ss\"</li></ul>",
        "operationId" : "getMeasurements",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "id",
          "in" : "query",
          "description" : "Measurement id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "variableName",
          "in" : "query",
          "description" : "Name of the variable you want measurements for",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "variableCategoryName",
          "in" : "query",
          "description" : "Name of the variable category you want measurements for",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "sourceName",
          "in" : "query",
          "description" : "ID of the source you want measurements for (supports exact name match only)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "value",
          "in" : "query",
          "description" : "Value of measurement",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "unitAbbreviatedName",
          "in" : "query",
          "description" : "The unit you want the measurements returned in",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "earliestMeasurementTime",
          "in" : "query",
          "description" : "The lower limit of measurements returned in ISO 8601 format or epoch seconds (unixtime)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "latestMeasurementTime",
          "in" : "query",
          "description" : "The upper limit of measurements returned in ISO 8601 format or epoch seconds (unixtime)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "createdAt",
          "in" : "query",
          "description" : "The time the measurement record was first created in the format YYYY-MM-DDThh:mm:ss. Time zone should be UTC and not local.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "updatedAt",
          "in" : "query",
          "description" : "The time the measurement record was last changed in the format YYYY-MM-DDThh:mm:ss. Time zone should be UTC and not local.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "groupingWidth",
          "in" : "query",
          "description" : "The time (in seconds) over which measurements are grouped together",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "groupingTimezone",
          "in" : "query",
          "description" : "The time (in seconds) over which measurements are grouped together",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "offset",
          "in" : "query",
          "description" : "Since the maximum limit is 200 records, to get more than that you'll have to make multiple API calls and page through the results. To retrieve all the data, you can iterate through data by using the `limit` and `offset` query parameters.  For example, if you want to retrieve data from 61-80 then you can use a query with the following parameters, `imit=20&offset=60`.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sort by given field. If the field is prefixed with `-, it will sort in descending order.",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "$ref" : "#/definitions/Measurement"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "readmeasurements" ]
        } ]
      },
      "post" : {
        "tags" : [ "measurements" ],
        "summary" : "Post a new set or update existing measurements to the database",
        "description" : "You can submit or update multiple measurements in a \"measurements\" sub-array.  If the variable these measurements correspond to does not already exist in the database, it will be automatically added.  The request body should look something like [{\"measurements\":[{\"startTime\":1439389320,\"value\":\"3\"}, {\"startTime\":1439389319,\"value\":\"2\"}],\"name\":\"Acne (out of 5)\",\"source\":\"QuantiModo\",\"category\":\"Symptoms\",\"combinationOperation\":\"MEAN\",\"unit\":\"/5\"}]",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "An array of measurements you want to insert.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/MeasurementSet"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Measurements successfully stored"
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "writemeasurements" ]
        } ]
      }
    },
    "/v1/measurements/delete" : {
      "post" : {
        "tags" : [ "measurements" ],
        "summary" : "Delete a measurement",
        "description" : "Delete a previously submitted measurement",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "The startTime and variableId of the measurement to be deleted.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/MeasurementDelete"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "$ref" : "#/definitions/CommonResponse"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "writemeasurements" ]
        } ]
      }
    },
    "/v1/measurements/update" : {
      "post" : {
        "tags" : [ "measurements" ],
        "summary" : "Update a measurement",
        "description" : "Delete a previously submitted measurement",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "body",
          "description" : "The id as well as the new startTime, note, and/or value of the measurement to be updated",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/MeasurementUpdate"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Successful Operation",
            "schema" : {
              "$ref" : "#/definitions/CommonResponse"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v2/measurements/request_csv" : {
      "post" : {
        "tags" : [ "measurements" ],
        "summary" : "Post Request for Measurements CSV",
        "description" : "Use this endpoint to schedule a CSV export containing all user measurements to be emailed to the user within 24 hours.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User's OAuth2 access token",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "type" : "integer"
            }
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v2/measurements/request_xls" : {
      "post" : {
        "tags" : [ "measurements" ],
        "summary" : "Post Request for Measurements XLS",
        "description" : "Use this endpoint to schedule a XLS export containing all user measurements to be emailed to the user within 24 hours.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User's OAuth2 access token",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "type" : "integer"
            }
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v2/measurements/request_pdf" : {
      "post" : {
        "tags" : [ "measurements" ],
        "summary" : "Post Request for Measurements PDF",
        "description" : "Use this endpoint to schedule a PDF export containing all user measurements to be emailed to the user within 24 hours.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User's OAuth2 access token",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "type" : "integer"
            }
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v2/measurements/csv" : {
      "get" : {
        "tags" : [ "measurements" ],
        "summary" : "Get Measurements CSV",
        "description" : "Download a CSV containing all user measurements",
        "produces" : [ "text/csv" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User's OAuth2 access token",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "type" : "file"
            }
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/measurementSources" : {
      "get" : {
        "tags" : [ "measurements" ],
        "summary" : "Get measurement sources",
        "description" : "Returns a list of all the apps from which measurement data is obtained.",
        "produces" : [ "application/json" ],
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "schema" : {
              "$ref" : "#/definitions/MeasurementSource"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      },
      "post" : {
        "tags" : [ "measurements" ],
        "summary" : "Add a data source",
        "description" : "Add a life-tracking app or device to the QuantiModo list of data sources.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "An array of names of data sources you want to add.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/MeasurementSource"
          }
        } ],
        "responses" : {
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v2/oauth/authorize" : {
      "get" : {
        "tags" : [ "authentication" ],
        "summary" : "Request Authorization Code",
        "description" : "You can implement OAuth2 authentication to your application using our **OAuth2** endpoints.  You need to redirect users to `/api/v2/oauth/authorize` endpoint to get an authorization code and include the parameters below.   This page will ask the user if they want to allow a client's application to submit or obtain data from their QM account. It will redirect the user to the url provided by the client application with the code as a query parameter or error in case of an error. See the /api/v2/oauth/access_token endpoint for the next steps.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "clientId",
          "in" : "query",
          "description" : "This is the unique ID that QuantiModo uses to identify your application. Obtain a client id by creating a free application at [https://app.quantimo.do/api/v2/apps](https://app.quantimo.do/api/v2/apps).",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "client_secret",
          "in" : "query",
          "description" : "This is the secret for your obtained clientId. QuantiModo uses this to validate that only your application uses the clientId.  Obtain this by creating a free application at [https://app.quantimo.do/api/v2/apps](https://app.quantimo.do/api/v2/apps).",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "response_type",
          "in" : "query",
          "description" : "If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "scope",
          "in" : "query",
          "description" : "Scopes include basic, readmeasurements, and writemeasurements. The \"basic\" scope allows you to read user info (displayname, email, etc). The \"readmeasurements\" scope allows one to read a user's data. The \"writemeasurements\" scope allows you to write user data. Separate multiple scopes by a space.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "redirect_uri",
          "in" : "query",
          "description" : "The redirect URI is the URL within your client application that will receive the OAuth2 credentials.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "state",
          "in" : "query",
          "description" : "An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation"
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v2/oauth2/access_token" : {
      "get" : {
        "tags" : [ "authentication" ],
        "summary" : "Get a user access token",
        "description" : "Client provides authorization token obtained from /api/v1/oauth2/authorize to this endpoint and receives an access token. Access token can then be used to query different API endpoints of QuantiModo. ### Request Access Token After user approves your access to the given scope form the https:/app.quantimo.do/v2/oauth2/authorize endpoint, you'll receive an authorization code to request an access token. This time make a `POST` request to `/api/v2/oauth/access_token` with parameters including: * `grant_type` Can be `authorization_code` or `refresh_token` since we are getting the `access_token` for the first time we don't have a `refresh_token` so this must be `authorization_code`. * `code` Authorization code you received with the previous request. * `redirect_uri` Your application's redirect url. ### Refreshing Access Token Access tokens expire at some point, to continue using our api you need to refresh them with `refresh_token` you received along with the `access_token`. To do this make a `POST` request to `/api/v2/oauth/access_token` with correct parameters, which are: * `grant_type` This time grant type must be `refresh_token` since we have it. * `clientId` Your application's client id. * `client_secret` Your application's client secret. * `refresh_token` The refresh token you received with the `access_token`. Every request you make to this endpoint will give you a new refresh token and make the old one expired. So you can keep getting new access tokens with new refresh tokens. ### Using Access Token Currently we support 2 ways for this, you can't use both at the same time. * Adding access token to the request header as `Authorization: Bearer {access_token}` * Adding to the url as a query parameter `?access_token={access_token}` You can read more about OAuth2 from [here](http://oauth.net/2/)",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "clientId",
          "in" : "query",
          "description" : "This is the unique ID that QuantiModo uses to identify your application. Obtain a client id by emailing info@quantimo.do.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "client_secret",
          "in" : "query",
          "description" : "This is the secret for your obtained clientId. QuantiModo uses this to validate that only your application uses the clientId.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "grant_type",
          "in" : "query",
          "description" : "Grant Type can be 'authorization_code' or 'refresh_token'",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "code",
          "in" : "query",
          "description" : "Authorization code you received with the previous request.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "response_type",
          "in" : "query",
          "description" : "If the value is code, launches a Basic flow, requiring a POST to the token endpoint to obtain the tokens. If the value is token id_token or id_token token, launches an Implicit flow, requiring the use of Javascript at the redirect URI to retrieve tokens from the URI #fragment.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "scope",
          "in" : "query",
          "description" : "Scopes include basic, readmeasurements, and writemeasurements. The \"basic\" scope allows you to read user info (displayname, email, etc). The \"readmeasurements\" scope allows one to read a user's data. The \"writemeasurements\" scope allows you to write user data. Separate multiple scopes by a space.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "redirect_uri",
          "in" : "query",
          "description" : "The redirect URI is the URL within your client application that will receive the OAuth2 credentials.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "state",
          "in" : "query",
          "description" : "An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation"
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v2/auth/social/login" : {
      "get" : {
        "tags" : [ "authentication" ],
        "summary" : "First Setp in Social Authentication flow with JWT Token",
        "description" : " Here is the flow for how social authentication works with a JWT Token\n1.**Client:** The client needs to open popup with social auth url (`https://app/quantimo.do/api/v2/auth/social/login?provider={provider}&redirectUrl={url}`) of server with `provider` and `redirectUrl`. (Url should be registered with our social apps. Facebook and Twitter are fine with any redirect url with the same domain base url but Google needs exact redirect url.) 2.**Server:** The QM server will redirect user to that provider to get access. 3.**Client:** After successful or failed authentication, it will be redirected to given `redirectUrl` with code or error. 4.**Client:** The client needs to get that code and needs to send an Ajax request to server at `https://app.quantimo.do/api/v2/auth/social/authorizeCode?provider={provider}&code={authorizationCode}` 5.**Server:** The QM server will authorize that code from the social connection and will authenticate user and will retrieve user info. 6.**Server:** The QM server will try to find existing user by unique identity. If the user already exists then it will login. Otherwise, it will create new user and will then login. 7.**Server:** Once user is found/created, it will return a JWT token for that user in the response.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "redirectUrl",
          "in" : "query",
          "description" : "The redirect URI is the URL within your client application that will receive the OAuth2 credentials. Url should be registered with our social apps. Facebook and Twitter are fine with any redirect url with the same domain base url but Google needs exact redirect url.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "provider",
          "in" : "query",
          "description" : "The current options are `google` and `facebook`.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation"
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v2/auth/social/authorizeCode" : {
      "get" : {
        "tags" : [ "authentication" ],
        "summary" : "Second Step in Social Authentication flow with JWT Token",
        "description" : " Here is the flow for how social authentication works with a JWT Token\n1.**Client:** The client needs to open popup with social auth url (`https://app/quantimo.do/api/v2/auth/social/login?provider={provider}&redirectUrl={url}`) of server with `provider` and `redirectUrl`. (Url should be registered with our social apps. Facebook is fine with any redirect url with the same domain base url but Google needs exact redirect url.) 2.**Server:** The QM server will redirect user to that provider to get access. 3.**Client:** After successful or failed authentication, it will be redirected to given `redirectUrl` with code or error. 4.**Client:** The client needs to get that code and needs to send an Ajax request to server at `https://app.quantimo.do/api/v2/auth/social/authorizeCode?provider={provider}&code={authorizationCode}` 5.**Server:** The QM server will authorize that code from the social connection and will authenticate user and will retrieve user info. 6.**Server:** The QM server will try to find existing user by unique identity. If the user already exists then it will login. Otherwise, it will create new user and will then login. 7.**Server:** Once user is found/created, it will return a JWT token for that user in the response.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "code",
          "in" : "query",
          "description" : "Authorization code obtained from the provider.",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "provider",
          "in" : "query",
          "description" : "The current options are `google` and `facebook`.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation"
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v2/auth/social/authorizeToken" : {
      "get" : {
        "tags" : [ "authentication" ],
        "summary" : "Native Social Authentication",
        "description" : "If you are using native authentication via Facebook or Google SDKs then you should use the following flow. 1.**Client:** Using native authentication via your native mobile app, get an access token using the instructions provided by the Facebook SDK (https://developers.facebook.com/docs/facebook-login) or Google (https://developers.google.com/identity/protocols/OAuth2) 2.**Client:** Send an Ajax request with provider name and access token on `https://app.quantimo.do/api/v2/auth/social/authorizeToken?provider={provider}&accessToken={accessToken}&refreshToken={refreshToken}` (`refreshToken` is optional) 3.**Server:** Server will try to get user info and will find existing user by unique identity. If user exist then it will do a login for that or it will create new user and will do login 4.**Server:** Once user is found/created, it will return a JWT token for that user in response 5.**Client:** After getting the JWT token to get a QM access token follow these steps and include your JWT token in them as a header (Authorization: Bearer **{yourJWThere}**) or as a url parameter (https://app.quantimo.do/api/v2/oauth/authorize?token={yourJWThere}).",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "refreshToken",
          "in" : "query",
          "description" : "Optional refresh token obtained from Google or FB native SDK",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "accessToken",
          "in" : "query",
          "description" : "User's OAuth2 access token obtained from Google or FB native SDK",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "provider",
          "in" : "query",
          "description" : "The current options are `google` and `facebook`.",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation"
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/organizations/{organizationId}/users" : {
      "post" : {
        "tags" : [ "organizations", "user" ],
        "summary" : "Get user tokens for existing users, create new users",
        "description" : "Get user tokens for existing users, create new users",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "organizationId",
          "in" : "path",
          "description" : "Organization ID",
          "required" : true,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Provides organization token and user ID",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/UserTokenRequest"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "User has been found, token was returned",
            "schema" : {
              "$ref" : "#/definitions/UserTokenSuccessfulResponse"
            }
          },
          "201" : {
            "description" : "User has been created, token was returned",
            "schema" : {
              "$ref" : "#/definitions/UserTokenSuccessfulResponse"
            }
          },
          "400" : {
            "description" : "Bad data",
            "schema" : {
              "$ref" : "#/definitions/UserTokenFailedResponse"
            }
          },
          "403" : {
            "description" : "Forbidden",
            "schema" : {
              "$ref" : "#/definitions/UserTokenFailedResponse"
            }
          }
        }
      }
    },
    "/v1/pairs" : {
      "get" : {
        "tags" : [ "pairs" ],
        "summary" : "Get pairs",
        "description" : "Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "cause",
          "in" : "query",
          "description" : "Original variable name for the explanatory or independent variable",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "causeSource",
          "in" : "query",
          "description" : "Name of data source that the cause measurements should come from",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "causeUnit",
          "in" : "query",
          "description" : "Abbreviated name for the unit cause measurements to be returned in",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "delay",
          "in" : "query",
          "description" : "The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the “onset delay”. For example, the “onset delay” between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "duration",
          "in" : "query",
          "description" : "The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "effect",
          "in" : "query",
          "description" : "Original variable name for the outcome or dependent variable",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "effectSource",
          "in" : "query",
          "description" : "Name of data source that the effectmeasurements should come from",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "effectUnit",
          "in" : "query",
          "description" : "Abbreviated name for the unit effect measurements to be returned in",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "endTime",
          "in" : "query",
          "description" : "The most recent date (in epoch time) for which we should return measurements",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "startTime",
          "in" : "query",
          "description" : "The earliest date (in epoch time) for which we should return measurements",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "offset",
          "in" : "query",
          "description" : "Since the maximum limit is 200 records, to get more than that you'll have to make multiple API calls and page through the results. To retrieve all the data, you can iterate through data by using the `limit` and `offset` query parameters.  For example, if you want to retrieve data from 61-80 then you can use a query with the following parameters, `imit=20&offset=60`.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sort by given field. If the field is prefixed with `-, it will sort in descending order.",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Pairs"
              }
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/pairsCsv" : {
      "get" : {
        "tags" : [ "pairs" ],
        "summary" : "Get pairs",
        "description" : "Pairs cause measurements with effect measurements grouped over the duration of action after the onset delay.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "cause",
          "in" : "query",
          "description" : "Original variable name for the explanatory or independent variable",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "causeSource",
          "in" : "query",
          "description" : "Name of data source that the cause measurements should come from",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "causeUnit",
          "in" : "query",
          "description" : "Abbreviated name for the unit cause measurements to be returned in",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "delay",
          "in" : "query",
          "description" : "The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the “onset delay”. For example, the “onset delay” between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "duration",
          "in" : "query",
          "description" : "The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "effect",
          "in" : "query",
          "description" : "Original variable name for the outcome or dependent variable",
          "required" : true,
          "type" : "string"
        }, {
          "name" : "effectSource",
          "in" : "query",
          "description" : "Name of data source that the effectmeasurements should come from",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "effectUnit",
          "in" : "query",
          "description" : "Abbreviated name for the unit effect measurements to be returned in",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "endTime",
          "in" : "query",
          "description" : "The most recent date (in epoch time) for which we should return measurements",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "startTime",
          "in" : "query",
          "description" : "The earliest date (in epoch time) for which we should return measurements",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "offset",
          "in" : "query",
          "description" : "Since the maximum limit is 200 records, to get more than that you'll have to make multiple API calls and page through the results. To retrieve all the data, you can iterate through data by using the `limit` and `offset` query parameters.  For example, if you want to retrieve data from 61-80 then you can use a query with the following parameters, `imit=20&offset=60`.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sort by given field. If the field is prefixed with `-, it will sort in descending order.",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/Pairs"
              }
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/trackingReminders" : {
      "get" : {
        "tags" : [ "reminders" ],
        "summary" : "Get repeating tracking reminder settings",
        "description" : "Users can be reminded to track certain variables at a specified frequency with a default value.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User's OAuth2 access token",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "variableCategoryName",
          "in" : "query",
          "description" : "Limit tracking reminders to a specific variable category",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "createdAt",
          "in" : "query",
          "description" : "When the record was first created. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format. Time zone should be UTC and not local.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "updatedAt",
          "in" : "query",
          "description" : "When the record was last updated. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format. Time zone should be UTC and not local.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "offset",
          "in" : "query",
          "description" : "OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sort by given field. If the field is prefixed with '-', it will sort in descending order.",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/inline_response_200"
            }
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      },
      "post" : {
        "tags" : [ "reminders" ],
        "summary" : "Store a Tracking Reminder",
        "description" : "This is to enable users to create reminders to track a variable with a default value at a specified frequency",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User's OAuth2 access token",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "TrackingReminder that should be stored",
          "required" : false,
          "schema" : {
            "$ref" : "#/definitions/TrackingReminder"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/inline_response_200_1"
            }
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/trackingReminders/delete" : {
      "post" : {
        "tags" : [ "reminders" ],
        "summary" : "Delete tracking reminder",
        "description" : "Delete previously created tracking reminder",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User's OAuth2 access token",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Id of reminder to be deleted",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/TrackingReminderDelete"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "$ref" : "#/definitions/CommonResponse"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/trackingReminderNotifications" : {
      "get" : {
        "tags" : [ "reminders" ],
        "summary" : "Get specific pending tracking reminders",
        "description" : "Specfic pending reminder instances that still need to be tracked.  ",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User's OAuth2 access token",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "variableCategoryName",
          "in" : "query",
          "description" : "Limit tracking reminder notifications to a specific variable category",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "createdAt",
          "in" : "query",
          "description" : "When the record was first created. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format. Time zone should be UTC and not local.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "updatedAt",
          "in" : "query",
          "description" : "When the record was last updated. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format. Time zone should be UTC and not local.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0. The maximum limit is 200 records.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "offset",
          "in" : "query",
          "description" : "OFFSET says to skip that many rows before beginning to return rows to the client. OFFSET 0 is the same as omitting the OFFSET clause. If both OFFSET and LIMIT appear, then OFFSET rows are skipped before starting to count the LIMIT rows that are returned.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sort by given field. If the field is prefixed with '-', it will sort in descending order.",
          "required" : false,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "successful operation",
            "schema" : {
              "$ref" : "#/definitions/inline_response_200_2"
            }
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      },
      "post" : {
        "tags" : [ "reminders" ],
        "summary" : "Snooze a pending tracking reminder",
        "description" : "Changes the reminder time to now plus one hour",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "access_token",
          "in" : "query",
          "description" : "User's OAuth2 access token",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Id of the pending reminder to be snoozed",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/TrackingReminderNotificationSnooze"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "$ref" : "#/definitions/CommonResponse"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/unitCategories" : {
      "get" : {
        "tags" : [ "units" ],
        "summary" : "Get unit categories",
        "description" : "Get a list of the categories of measurement units such as 'Distance', 'Duration', 'Energy', 'Frequency', 'Miscellany', 'Pressure', 'Proportion', 'Rating', 'Temperature', 'Volume', and 'Weight'.",
        "produces" : [ "application/json" ],
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "schema" : {
              "$ref" : "#/definitions/UnitCategory"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/user/me" : {
      "get" : {
        "tags" : [ "user" ],
        "summary" : "Get all available units for variableGet authenticated user",
        "description" : "Returns user info for the currently authenticated user.",
        "produces" : [ "application/json" ],
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "schema" : {
              "$ref" : "#/definitions/User"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/userTags" : {
      "post" : {
        "tags" : [ "tags" ],
        "summary" : "Post or update user tags or ingredients",
        "description" : "This endpoint allows users to tag foods with their ingredients.  This information will then be used to infer the user intake of the different ingredients by just entering the foods. The inferred intake levels will then be used to determine the effects of different nutrients on the user during analysis.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Contains the new user tag data",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/UserTag"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "$ref" : "#/definitions/CommonResponse"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/userTags/delete" : {
      "post" : {
        "tags" : [ "tags" ],
        "summary" : "Delete user tag or ingredient",
        "description" : "Delete previously created user tags or ingredients.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "taggedVariableId",
          "in" : "query",
          "description" : "This is the id of the variable being tagged with an ingredient or something.",
          "required" : true,
          "type" : "integer"
        }, {
          "name" : "tagVariableId",
          "in" : "query",
          "description" : "This is the id of the ingredient variable whose value is determined based on the value of the tagged variable.",
          "required" : true,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "$ref" : "#/definitions/CommonResponse"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/variables" : {
      "get" : {
        "tags" : [ "variables" ],
        "summary" : "Get variables with user's settings",
        "description" : "Get variables for which the user has measurements. If the user has specified variable settings, these are provided instead of the common variable defaults.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "id",
          "in" : "query",
          "description" : "Common variable id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "category",
          "in" : "query",
          "description" : "Filter data by category",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "Original name of the variable (supports exact name match only)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "updatedAt",
          "in" : "query",
          "description" : "Filter by the last time any of the properties of the variable were changed. Uses UTC format \"YYYY-MM-DDThh:mm:ss\"",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "source",
          "in" : "query",
          "description" : "The name of the data source that created the variable (supports exact name match only). So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "latestMeasurementTime",
          "in" : "query",
          "description" : "Filter variables based on the last time a measurement for them was created or updated in the UTC format \"YYYY-MM-DDThh:mm:ss\"",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "numberOfRawMeasurements",
          "in" : "query",
          "description" : "Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "lastSource",
          "in" : "query",
          "description" : "Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here. (supports exact name match only)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "offset",
          "in" : "query",
          "description" : "Since the maximum limit is 200 records, to get more than that you'll have to make multiple API calls and page through the results. To retrieve all the data, you can iterate through data by using the `limit` and `offset` query parameters.  For example, if you want to retrieve data from 61-80 then you can use a query with the following parameters, `imit=20&offset=60`.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sort by given field. If the field is prefixed with `-, it will sort in descending order.",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "Variables returned",
            "schema" : {
              "$ref" : "#/definitions/Variable"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      },
      "post" : {
        "tags" : [ "variables" ],
        "summary" : "Create Variables",
        "description" : "Allows the client to create a new variable in the `variables` table.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Original name for the variable.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/VariablesNew"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation"
          },
          "201" : {
            "description" : "Variable created"
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/variables/{variableName}" : {
      "get" : {
        "tags" : [ "variables" ],
        "summary" : "Get info about a variable",
        "description" : "Get all of the settings and information about a variable by its name. If the logged in user has modified the settings for the variable, these will be provided instead of the default settings for that variable.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "variableName",
          "in" : "path",
          "description" : "Variable name",
          "required" : true,
          "type" : "string"
        } ],
        "responses" : {
          "200" : {
            "description" : "Variables returned",
            "schema" : {
              "$ref" : "#/definitions/Variable"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/public/variables" : {
      "get" : {
        "tags" : [ "variables" ],
        "summary" : "Get public variables",
        "description" : "This endpoint retrieves an array of all public variables. Public variables are things like foods, medications, symptoms, conditions, and anything not unique to a particular user. For instance, a telephone number or name would not be a public variable.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "id",
          "in" : "query",
          "description" : "Common variable id",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "category",
          "in" : "query",
          "description" : "Filter data by category",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "name",
          "in" : "query",
          "description" : "Original name of the variable (supports exact name match only)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "updatedAt",
          "in" : "query",
          "description" : "Filter by the last time any of the properties of the variable were changed. Uses UTC format \"YYYY-MM-DDThh:mm:ss\"",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "source",
          "in" : "query",
          "description" : "The name of the data source that created the variable (supports exact name match only). So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "latestMeasurementTime",
          "in" : "query",
          "description" : "Filter variables based on the last time a measurement for them was created or updated in the UTC format \"YYYY-MM-DDThh:mm:ss\"",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "numberOfRawMeasurements",
          "in" : "query",
          "description" : "Filter variables by the total number of measurements that they have. This could be used of you want to filter or sort by popularity.",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "lastSource",
          "in" : "query",
          "description" : "Limit variables to those which measurements were last submitted by a specific source. So if you have a client application and you only want variables that were last updated by your app, you can include the name of your app here. (supports exact name match only)",
          "required" : false,
          "type" : "string"
        }, {
          "name" : "limit",
          "in" : "query",
          "description" : "The LIMIT is used to limit the number of results returned. So if you have 1000 results, but only want to the first 10, you would set this to 10 and offset to 0.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "offset",
          "in" : "query",
          "description" : "Since the maximum limit is 200 records, to get more than that you'll have to make multiple API calls and page through the results. To retrieve all the data, you can iterate through data by using the `limit` and `offset` query parameters.  For example, if you want to retrieve data from 61-80 then you can use a query with the following parameters, `imit=20&offset=60`.",
          "required" : false,
          "type" : "integer"
        }, {
          "name" : "sort",
          "in" : "query",
          "description" : "Sort by given field. If the field is prefixed with `-, it will sort in descending order.",
          "required" : false,
          "type" : "integer"
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "schema" : {
              "$ref" : "#/definitions/Variable"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/userVariables" : {
      "post" : {
        "tags" : [ "variables" ],
        "summary" : "Update User Settings for a Variable",
        "description" : "Users can change the parameters used in analysis of that variable such as the expected duration of action for a variable to have an effect, the estimated delay before the onset of action. In order to filter out erroneous data, they are able to set the maximum and minimum reasonable daily values for a variable.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "userVariables",
          "description" : "Variable user settings data",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/UserVariables"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation"
          },
          "400" : {
            "description" : "The received JSON was invalid or malformed"
          },
          "401" : {
            "description" : "Not Authenticated"
          },
          "404" : {
            "description" : "Unknown target user ID"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/userVariables/delete" : {
      "post" : {
        "tags" : [ "variables" ],
        "summary" : "Delete All Measurements For Variable",
        "description" : "Users can delete all of their measurements for a variable",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "variableId",
          "description" : "Id of the variable whose measurements should be deleted",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/UserVariableDelete"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful operation"
          },
          "400" : {
            "description" : "The received JSON was invalid or malformed"
          },
          "401" : {
            "description" : "Not Authenticated"
          },
          "404" : {
            "description" : "Unknown target user ID"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/userVariables/reset" : {
      "post" : {
        "tags" : [ "variables" ],
        "summary" : "Reset user settings for a variable to defaults",
        "description" : "Reset user settings for a variable to defaults",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "in" : "body",
          "name" : "variableId",
          "description" : "Id of the variable that should be reset",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/UserVariableDelete"
          }
        } ],
        "responses" : {
          "201" : {
            "description" : "Successful operation"
          },
          "400" : {
            "description" : "The received JSON was invalid or malformed"
          },
          "401" : {
            "description" : "Not Authenticated"
          },
          "404" : {
            "description" : "Unknown target user ID"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/variableCategories" : {
      "get" : {
        "tags" : [ "variables" ],
        "summary" : "Variable categories",
        "description" : "The variable categories include Activity, Causes of Illness, Cognitive Performance, Conditions, Environment, Foods, Location, Miscellaneous, Mood, Nutrition, Physical Activity, Physique, Sleep, Social Interactions, Symptoms, Treatments, Vital Signs, and Work.",
        "produces" : [ "application/json" ],
        "parameters" : [ ],
        "responses" : {
          "200" : {
            "description" : "Successful operation",
            "schema" : {
              "type" : "array",
              "items" : {
                "$ref" : "#/definitions/VariableCategory"
              }
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/votes" : {
      "post" : {
        "tags" : [ "correlations", "votes" ],
        "summary" : "Post or update vote",
        "description" : "This is to enable users to indicate their opinion on the plausibility of a causal relationship between a treatment and outcome. QuantiModo incorporates crowd-sourced plausibility estimations into their algorithm. This is done allowing user to indicate their view of the plausibility of each relationship with thumbs up/down buttons placed next to each prediction.",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "Contains the cause variable, effect variable, and vote value.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/PostVote"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "$ref" : "#/definitions/CommonResponse"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    },
    "/v1/votes/delete" : {
      "post" : {
        "tags" : [ "correlations", "votes" ],
        "summary" : "Delete vote",
        "description" : "Delete previously posted vote",
        "produces" : [ "application/json" ],
        "parameters" : [ {
          "name" : "userId",
          "in" : "query",
          "description" : "User's id",
          "required" : false,
          "type" : "integer"
        }, {
          "in" : "body",
          "name" : "body",
          "description" : "The cause and effect variable names for the predictor vote to be deleted.",
          "required" : true,
          "schema" : {
            "$ref" : "#/definitions/VoteDelete"
          }
        } ],
        "responses" : {
          "200" : {
            "description" : "Successful Operation",
            "schema" : {
              "$ref" : "#/definitions/CommonResponse"
            }
          },
          "401" : {
            "description" : "Not Authenticated"
          }
        },
        "security" : [ {
          "access_token" : [ ]
        }, {
          "quantimodo_oauth2" : [ "basic" ]
        } ]
      }
    }
  },
  "securityDefinitions" : {
    "quantimodo_oauth2" : {
      "type" : "oauth2",
      "authorizationUrl" : "https://app.quantimo.do/api/v2/oauth/authorize",
      "tokenUrl" : "https://app.quantimo.do/api/v2/oauth/token",
      "flow" : "accessCode",
      "scopes" : {
        "basic" : "Allows you to read user info (displayname, email, etc).",
        "readmeasurements" : "Allows one to read a user's data",
        "writemeasurements" : "Allows you to write user data"
      }
    },
    "access_token" : {
      "type" : "apiKey",
      "name" : "access_token",
      "in" : "query"
    }
  },
  "definitions" : {
    "CommonResponse" : {
      "type" : "object",
      "required" : [ "status", "success" ],
      "properties" : {
        "status" : {
          "type" : "integer",
          "description" : "Status code"
        },
        "message" : {
          "type" : "string",
          "description" : "Message"
        },
        "success" : {
          "type" : "boolean"
        }
      }
    },
    "ConnectorInstruction" : {
      "properties" : {
        "url" : {
          "type" : "string",
          "description" : "url"
        },
        "parameters" : {
          "type" : "array",
          "description" : "parameters array",
          "items" : {
            "type" : "string"
          }
        },
        "usePopup" : {
          "type" : "boolean",
          "description" : "usePopup"
        }
      }
    },
    "Connector" : {
      "required" : [ "connectInstructions", "connected", "displayName", "getItUrl", "id", "image", "lastUpdate", "name", "totalMeasurementsInLastUpdate" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "Connector ID number"
        },
        "name" : {
          "type" : "string",
          "description" : "Connector lowercase system name"
        },
        "displayName" : {
          "type" : "string",
          "description" : "Connector pretty display name"
        },
        "image" : {
          "type" : "string",
          "description" : "URL to the image of the connector logo"
        },
        "getItUrl" : {
          "type" : "string",
          "description" : "URL to a site where one can get this device or application"
        },
        "connected" : {
          "type" : "string",
          "description" : "True if the authenticated user has this connector enabled"
        },
        "connectInstructions" : {
          "type" : "string",
          "description" : "URL and parameters used when connecting to a service"
        },
        "lastUpdate" : {
          "type" : "integer",
          "description" : "Epoch timestamp of last sync"
        },
        "totalMeasurementsInLastUpdate" : {
          "type" : "integer",
          "description" : "Number of measurements obtained during latest update"
        }
      }
    },
    "ConnectorInfo" : {
      "required" : [ "connected", "error", "history", "id" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "Connector ID number"
        },
        "connected" : {
          "type" : "boolean",
          "description" : "True if the authenticated user has this connector enabled"
        },
        "error" : {
          "type" : "string",
          "description" : "Error message. Empty if connected."
        },
        "history" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/ConnectorInfoHistoryItem"
          }
        }
      }
    },
    "ConnectorInfoHistoryItem" : {
      "required" : [ "createdAt", "message", "numberOfMeasurements", "success" ],
      "properties" : {
        "numberOfMeasurements" : {
          "type" : "integer",
          "description" : "Number of measurements"
        },
        "success" : {
          "type" : "boolean",
          "description" : "True if the update was successfull"
        },
        "message" : {
          "type" : "string",
          "description" : "Error message."
        },
        "createdAt" : {
          "type" : "string",
          "description" : "Date and time of the update in UTC time zone"
        }
      }
    },
    "ConversionStep" : {
      "required" : [ "operation", "value" ],
      "properties" : {
        "operation" : {
          "type" : "string",
          "description" : "ADD or MULTIPLY",
          "enum" : [ "MULTIPLY", "ADD" ]
        },
        "value" : {
          "type" : "number",
          "format" : "double",
          "description" : "This specifies the order of conversion steps starting with 0"
        }
      }
    },
    "Correlation" : {
      "required" : [ "cause", "correlationCoefficient", "durationOfAction", "effect", "numberOfPairs", "onsetDelay", "timestamp" ],
      "properties" : {
        "averageDailyLowCause" : {
          "type" : "number",
          "description" : ""
        },
        "averageDailyHighCause" : {
          "type" : "number",
          "description" : ""
        },
        "averageEffect" : {
          "type" : "number",
          "description" : ""
        },
        "averageEffectFollowingHighCause" : {
          "type" : "number",
          "description" : ""
        },
        "averageEffectFollowingLowCause" : {
          "type" : "number",
          "description" : ""
        },
        "averageEffectFollowingHighCauseExplanation" : {
          "type" : "string",
          "description" : ""
        },
        "averageEffectFollowingLowCauseExplanation" : {
          "type" : "string",
          "description" : ""
        },
        "averageVote" : {
          "type" : "number",
          "description" : "Average Vote"
        },
        "causalityFactor" : {
          "type" : "number",
          "description" : ""
        },
        "cause" : {
          "type" : "string",
          "description" : "Variable name of the cause variable for which the user desires correlations."
        },
        "causeVariableCategoryName" : {
          "type" : "string",
          "description" : "Variable category of the cause variable."
        },
        "causeChanges" : {
          "type" : "integer",
          "description" : "Number of changes in the predictor variable (a.k.a the number of experiments)"
        },
        "causeVariableCombinationOperation" : {
          "type" : "string",
          "description" : "The way cause measurements are aggregated"
        },
        "causeVariableImageUrl" : {
          "type" : "string",
          "description" : ""
        },
        "causeVariableIonIcon" : {
          "type" : "string",
          "description" : "For use in Ionic apps"
        },
        "causeUnit" : {
          "type" : "string",
          "description" : "Unit of the predictor variable"
        },
        "causeVariableDefaultUnitId" : {
          "type" : "integer",
          "description" : "Unit Id of the predictor variable"
        },
        "causeVariableId" : {
          "type" : "integer",
          "description" : ""
        },
        "causeVariableName" : {
          "type" : "string",
          "description" : "Variable name of the cause variable for which the user desires correlations."
        },
        "correlationCoefficient" : {
          "type" : "number",
          "description" : "Pearson correlation coefficient between cause and effect measurements"
        },
        "createdAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record was first created. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        },
        "dataAnalysis" : {
          "type" : "string",
          "description" : "How the data was analyzed"
        },
        "dataSources" : {
          "type" : "string",
          "description" : "How the data was obtained"
        },
        "durationOfAction" : {
          "type" : "number",
          "description" : "The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay."
        },
        "effect" : {
          "type" : "string",
          "description" : "Variable name of the effect variable for which the user desires correlations."
        },
        "effectVariableCategoryName" : {
          "type" : "string",
          "description" : "Variable category of the effect variable."
        },
        "effectVariableImageUrl" : {
          "type" : "string",
          "description" : ""
        },
        "effectVariableIonIcon" : {
          "type" : "string",
          "description" : "For use in Ionic apps"
        },
        "effectSize" : {
          "type" : "string",
          "description" : "Magnitude of the effects of a cause indicating whether it's practically meaningful."
        },
        "effectVariableId" : {
          "type" : "string",
          "description" : "Magnitude of the effects of a cause indicating whether it's practically meaningful."
        },
        "effectVariableName" : {
          "type" : "string",
          "description" : "Variable name of the effect variable for which the user desires correlations."
        },
        "gaugeImage" : {
          "type" : "string",
          "description" : "Illustrates the strength of the relationship"
        },
        "imageUrl" : {
          "type" : "string",
          "description" : "Large image for Facebook"
        },
        "numberOfPairs" : {
          "type" : "number",
          "description" : "Number of points that went into the correlation calculation"
        },
        "onsetDelay" : {
          "type" : "number",
          "format" : "double",
          "description" : "The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the “onset delay”. For example, the “onset delay” between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes."
        },
        "optimalPearsonProduct" : {
          "type" : "number",
          "description" : "Optimal Pearson Product"
        },
        "outcomeDataSources" : {
          "type" : "string",
          "description" : "original name of the cause."
        },
        "predictorExplanation" : {
          "type" : "string",
          "description" : "HIGHER Remeron predicts HIGHER Overall Mood"
        },
        "principalInvestigator" : {
          "type" : "string",
          "description" : "Mike Sinn"
        },
        "qmScore" : {
          "type" : "number",
          "description" : "Value representing the significance of the relationship as a function of crowdsourced insights, predictive strength, data quantity, and data quality"
        },
        "reverseCorrelation" : {
          "type" : "number",
          "description" : "Correlation when cause and effect are reversed. For any causal relationship, the forward correlation should exceed the reverse correlation."
        },
        "significanceExplanation" : {
          "type" : "string",
          "description" : "Using a two-tailed t-test with alpha = 0.05, it was determined that the change..."
        },
        "statisticalSignificance" : {
          "type" : "string",
          "description" : "A function of the effect size and sample size"
        },
        "strengthLevel" : {
          "type" : "string",
          "description" : "weak, moderate, strong"
        },
        "studyAbstract" : {
          "type" : "string",
          "description" : "These data suggest with a high degree of confidence..."
        },
        "studyBackground" : {
          "type" : "string",
          "description" : "In order to reduce suffering through the advancement of human knowledge..."
        },
        "studyDesign" : {
          "type" : "string",
          "description" : "This study is based on data donated by one QuantiModo user..."
        },
        "studyLimitations" : {
          "type" : "string",
          "description" : "As with any human experiment, it was impossible to control for all potentially confounding variables..."
        },
        "studyLinkDynamic" : {
          "type" : "string",
          "description" : "Url for the interactive study within the web app"
        },
        "studyLinkFacebook" : {
          "type" : "string",
          "description" : "Url for sharing the study on Facebook"
        },
        "studyLinkGoogle" : {
          "type" : "string",
          "description" : "Url for sharing the study on Google+"
        },
        "studyLinkTwitter" : {
          "type" : "string",
          "description" : "Url for sharing the study on Twitter"
        },
        "studyLinkStatic" : {
          "type" : "string",
          "description" : "Url for sharing the statically rendered study on social media"
        },
        "studyObjective" : {
          "type" : "string",
          "description" : "The objective of this study is to determine..."
        },
        "studyResults" : {
          "type" : "string",
          "description" : "This analysis suggests that..."
        },
        "studyTitle" : {
          "type" : "string",
          "description" : "N1 Study HIGHER Remeron predicts HIGHER Overall Mood"
        },
        "timestamp" : {
          "type" : "number",
          "description" : "Time at which correlation was calculated"
        },
        "updatedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record in the database was last updated. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format. Time zone should be UTC and not local."
        },
        "userVote" : {
          "type" : "number",
          "description" : "User Vote"
        },
        "valuePredictingHighOutcome" : {
          "type" : "number",
          "description" : "cause value that predicts an above average effect value (in default unit for cause variable)"
        },
        "valuePredictingHighOutcomeExplanation" : {
          "type" : "string",
          "description" : "Overall Mood, on average, 34% HIGHER after around 3.98mg Remeron"
        },
        "valuePredictingLowOutcome" : {
          "type" : "number",
          "description" : "cause value that predicts a below average effect value (in default unit for cause variable)"
        },
        "valuePredictingLowOutcomeExplanation" : {
          "type" : "string",
          "description" : "Overall Mood, on average, 4% LOWER after around 0mg Remeron"
        }
      }
    },
    "Connection" : {
      "required" : [ "connectorId" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "id"
        },
        "userId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of user that owns this correlation"
        },
        "connectorId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The id for the connector data source for which the connection is connected"
        },
        "connectStatus" : {
          "type" : "string",
          "description" : "Indicates whether a connector is currently connected to a service for a user."
        },
        "connectError" : {
          "type" : "string",
          "description" : "Error message if there is a problem with authorizing this connection."
        },
        "updateRequestedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Time at which an update was requested by a user."
        },
        "updateStatus" : {
          "type" : "string",
          "description" : "Indicates whether a connector is currently updated."
        },
        "updateError" : {
          "type" : "string",
          "description" : "Indicates if there was an error during the update."
        },
        "lastSuccessfulUpdatedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "The time at which the connector was last successfully updated."
        },
        "createdAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record was first created. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        },
        "updatedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record in the database was last updated. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        }
      }
    },
    "HumanTime" : {
      "type" : "object",
      "properties" : {
        "date" : {
          "type" : "string",
          "description" : "date time"
        },
        "timezone_type" : {
          "type" : "integer"
        },
        "timezone" : {
          "type" : "string",
          "description" : "timezone of date time"
        }
      }
    },
    "JsonErrorResponse" : {
      "required" : [ "status" ],
      "properties" : {
        "status" : {
          "type" : "string",
          "description" : "Status: \"ok\" or \"error\""
        },
        "message" : {
          "type" : "string",
          "description" : "Error message"
        }
      }
    },
    "MeasurementSet" : {
      "required" : [ "measurements", "sourceName", "unitAbbreviatedName", "variableName" ],
      "properties" : {
        "measurements" : {
          "type" : "array",
          "description" : "Array of timestamps, values, and optional notes",
          "items" : {
            "$ref" : "#/definitions/ValueObject"
          }
        },
        "variableName" : {
          "type" : "string",
          "description" : "ORIGINAL name of the variable for which we are creating the measurement records"
        },
        "sourceName" : {
          "type" : "string",
          "description" : "Name of the application or device used to record the measurement values"
        },
        "variableCategoryName" : {
          "type" : "string",
          "description" : "Variable category name"
        },
        "combinationOperation" : {
          "type" : "string",
          "description" : "Way to aggregate measurements over time. Options are \"MEAN\" or \"SUM\". SUM should be used for things like minutes of exercise.  If you use MEAN for exercise, then a person might exercise more minutes in one day but add separate measurements that were smaller.  So when we are doing correlational analysis, we would think that the person exercised less that day even though they exercised more.  Conversely, we must use MEAN for things such as ratings which cannot be SUMMED.",
          "enum" : [ "MEAN", "SUM" ]
        },
        "unitAbbreviatedName" : {
          "type" : "string",
          "description" : "Unit of measurement"
        }
      }
    },
    "Measurement" : {
      "required" : [ "sourceName", "startTimeString", "unitAbbreviatedName", "value", "variableName" ],
      "properties" : {
        "variableName" : {
          "type" : "string",
          "description" : "Name of the variable for which we are creating the measurement records"
        },
        "sourceName" : {
          "type" : "string",
          "description" : "Application or device used to record the measurement values"
        },
        "startTimeString" : {
          "type" : "string",
          "description" : "Start Time for the measurement event in UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\""
        },
        "startTimeEpoch" : {
          "type" : "integer",
          "description" : "Seconds between the start of the event measured and 1970 (Unix timestamp)"
        },
        "humanTime" : {
          "$ref" : "#/definitions/HumanTime"
        },
        "value" : {
          "type" : "number",
          "format" : "double",
          "description" : "Converted measurement value in requested unit"
        },
        "originalValue" : {
          "type" : "integer",
          "description" : "Original value as originally submitted"
        },
        "originalunitAbbreviatedName" : {
          "type" : "string",
          "description" : "Original Unit of measurement as originally submitted"
        },
        "unitAbbreviatedName" : {
          "type" : "string",
          "description" : "Abbreviated name for the unit of measurement"
        },
        "note" : {
          "type" : "string",
          "description" : "Note of measurement"
        }
      }
    },
    "MeasurementDelete" : {
      "required" : [ "startTime", "variableId" ],
      "properties" : {
        "variableId" : {
          "type" : "integer",
          "description" : "Variable id of the measurement to be deleted"
        },
        "startTime" : {
          "type" : "integer",
          "description" : "Start time of the measurement to be deleted"
        }
      }
    },
    "MeasurementUpdate" : {
      "required" : [ "id" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "Variable id of the measurement to be deleted"
        },
        "startTime" : {
          "type" : "integer",
          "description" : "The new timestamp for the the event in epoch seconds (optional)"
        },
        "value" : {
          "type" : "number",
          "format" : "double",
          "description" : "The new value of for the measurement (optional)"
        },
        "note" : {
          "type" : "string",
          "description" : "The new note for the measurement (optional)"
        }
      }
    },
    "MeasurementRange" : {
      "required" : [ "lowerLimit" ],
      "properties" : {
        "lowerLimit" : {
          "type" : "integer",
          "description" : "The timestamp of the earliest measurement for a user."
        },
        "upperLimit" : {
          "type" : "integer",
          "description" : "The timestamp of the most recent measurement for a user."
        }
      }
    },
    "MeasurementSource" : {
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "Name of the application or device."
        }
      }
    },
    "Pairs" : {
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "Category name"
        }
      }
    },
    "Permission" : {
      "required" : [ "maxTimeOfDay", "maxTimestamp", "minTimeOfDay", "minTimestamp", "target", "variableName", "week" ],
      "properties" : {
        "target" : {
          "type" : "integer",
          "description" : "Grant permission to target user or public so they may access measurements within the given parameters. TODO: Rename target to something more intuitive."
        },
        "variableName" : {
          "type" : "string",
          "description" : "ORIGINAL Variable name"
        },
        "minTimestamp" : {
          "type" : "integer",
          "description" : "Earliest time when measurements will be accessible in epoch seconds"
        },
        "maxTimestamp" : {
          "type" : "integer",
          "description" : "Latest time when measurements will be accessible in epoch seconds"
        },
        "minTimeOfDay" : {
          "type" : "integer",
          "description" : "Earliest time of day when measurements will be accessible in epoch seconds"
        },
        "maxTimeOfDay" : {
          "type" : "integer",
          "description" : "Latest time of day when measurements will be accessible in epoch seconds"
        },
        "week" : {
          "type" : "string",
          "description" : "Maybe specifies if only weekday measurements should be accessible"
        }
      }
    },
    "PostVote" : {
      "required" : [ "causeVariableId", "effectVariableId", "vote" ],
      "properties" : {
        "causeVariableId" : {
          "type" : "integer",
          "description" : "Cause variable id"
        },
        "effectVariableId" : {
          "type" : "integer",
          "description" : "Effect variable id"
        },
        "vote" : {
          "type" : "boolean",
          "description" : "Vote: 0 (for implausible) or 1 (for plausible)"
        }
      }
    },
    "PostCorrelation" : {
      "required" : [ "causeVariableName", "correlation", "effectVariableName" ],
      "properties" : {
        "causeVariableName" : {
          "type" : "string",
          "description" : "Cause variable name"
        },
        "effectVariableName" : {
          "type" : "string",
          "description" : "Effect variable name"
        },
        "correlation" : {
          "type" : "number",
          "format" : "double",
          "description" : "Correlation value"
        },
        "vote" : {
          "type" : "integer",
          "description" : "Vote: 0 or 1"
        }
      }
    },
    "UserVariableDelete" : {
      "required" : [ "variableId" ],
      "properties" : {
        "variableId" : {
          "type" : "integer",
          "description" : "Id of the variable whose measurements should be deleted"
        }
      }
    },
    "TrackingReminderDelete" : {
      "required" : [ "id" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "Id of the PENDING reminder to be deleted"
        }
      }
    },
    "TrackingReminderNotificationSkip" : {
      "required" : [ "id" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "Id of the PENDING reminder to be skipped"
        }
      }
    },
    "TrackingReminderNotificationSnooze" : {
      "required" : [ "id" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "Id of the PENDING reminder to be snoozed"
        }
      }
    },
    "TrackingReminderNotificationTrack" : {
      "required" : [ "trackingReminderNotification" ],
      "properties" : {
        "trackingReminderNotification" : {
          "$ref" : "#/definitions/TrackingReminderNotification"
        },
        "modifiedValue" : {
          "type" : "number",
          "description" : "Optional value to be recorded instead of the tracking reminder default value"
        }
      }
    },
    "TrackingReminder" : {
      "required" : [ "defaultValue", "reminderFrequency", "variableId" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "id"
        },
        "clientId" : {
          "type" : "string",
          "description" : "clientId"
        },
        "userId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of User"
        },
        "variableId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Id for the variable to be tracked"
        },
        "defaultValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "Default value to use for the measurement when tracking"
        },
        "reminderStartTime" : {
          "type" : "string",
          "description" : "Earliest time of day at which reminders should appear in UTC HH:MM:SS format"
        },
        "reminderEndTime" : {
          "type" : "string",
          "description" : "Latest time of day at which reminders should appear in UTC HH:MM:SS format"
        },
        "reminderSound" : {
          "type" : "string",
          "description" : "String identifier for the sound to accompany the reminder"
        },
        "reminderFrequency" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of seconds between one reminder and the next"
        },
        "popUp" : {
          "type" : "boolean",
          "description" : "True if the reminders should appear as a popup notification"
        },
        "sms" : {
          "type" : "boolean",
          "description" : "True if the reminders should be delivered via SMS"
        },
        "email" : {
          "type" : "boolean",
          "description" : "True if the reminders should be delivered via email"
        },
        "notificationBar" : {
          "type" : "boolean",
          "description" : "True if the reminders should appear in the notification bar"
        },
        "latestTrackingReminderNotificationReminderTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  timestamp for the reminder time of the latest tracking reminder notification that has been pre-emptively generated in the database"
        },
        "lastTracked" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  timestamp for the last time a measurement was received for this user and variable"
        },
        "startTrackingDate" : {
          "type" : "string",
          "format" : "string",
          "description" : "Earliest date on which the user should be reminded to track in YYYY-MM-DD format"
        },
        "stopTrackingDate" : {
          "type" : "string",
          "format" : "string",
          "description" : "Latest date on which the user should be reminded to track in YYYY-MM-DD format"
        },
        "updatedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record in the database was last updated. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format. Time zone should be UTC and not local."
        },
        "variableName" : {
          "type" : "string",
          "description" : "Name of the variable to be used when sending measurements"
        },
        "variableCategoryName" : {
          "type" : "string",
          "description" : "Name of the variable category to be used when sending measurements"
        },
        "unitAbbreviatedName" : {
          "type" : "string",
          "description" : "Abbreviated name of the unit to be used when sending measurements"
        },
        "combinationOperation" : {
          "type" : "string",
          "description" : "The way multiple measurements are aggregated over time",
          "enum" : [ "MEAN", "SUM" ]
        }
      }
    },
    "TrackingReminderNotification" : {
      "required" : [ "id", "trackingReminderId" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "id for the specific PENDING tracking remidner"
        },
        "trackingReminderId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "id for the repeating tracking remidner"
        },
        "clientId" : {
          "type" : "string",
          "description" : "clientId"
        },
        "userId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of User"
        },
        "variableId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Id for the variable to be tracked"
        },
        "pendingReminderTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  timestamp for the specific time the variable should be tracked in UTC.  This will be used for the measurement startTime if the track endpoint is used."
        },
        "defaultValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "Default value to use for the measurement when tracking"
        },
        "reminderSound" : {
          "type" : "string",
          "description" : "String identifier for the sound to accompany the reminder"
        },
        "popUp" : {
          "type" : "boolean",
          "description" : "True if the reminders should appear as a popup notification"
        },
        "sms" : {
          "type" : "boolean",
          "description" : "True if the reminders should be delivered via SMS"
        },
        "email" : {
          "type" : "boolean",
          "description" : "True if the reminders should be delivered via email"
        },
        "notificationBar" : {
          "type" : "boolean",
          "description" : "True if the reminders should appear in the notification bar"
        },
        "updatedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record in the database was last updated. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format. Time zone should be UTC and not local."
        },
        "variableName" : {
          "type" : "string",
          "description" : "Name of the variable to be used when sending measurements"
        },
        "variableCategoryName" : {
          "type" : "string",
          "description" : "Name of the variable category to be used when sending measurements"
        },
        "unitAbbreviatedName" : {
          "type" : "string",
          "description" : "Abbreviated name of the unit to be used when sending measurements"
        },
        "combinationOperation" : {
          "type" : "string",
          "description" : "The way multiple measurements are aggregated over time",
          "enum" : [ "MEAN", "SUM" ]
        }
      }
    },
    "Unit" : {
      "required" : [ "abbreviatedName", "category", "conversionSteps", "name" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "Unit name"
        },
        "abbreviatedName" : {
          "type" : "string",
          "description" : "Unit abbreviation"
        },
        "category" : {
          "type" : "string",
          "description" : "Unit category",
          "enum" : [ "Distance", "Duration", "Energy", "Frequency", "Miscellany", "Pressure", "Proportion", "Rating", "Temperature", "Volume", "Weight" ]
        },
        "minimumAllowedValue" : {
          "type" : "number",
          "format" : "double",
          "description" : "The minimum allowed value for measurements. While you can record a value below this minimum, it will be excluded from the correlation analysis."
        },
        "maximumAllowedValue" : {
          "type" : "number",
          "format" : "double",
          "description" : "The maximum allowed value for measurements. While you can record a value above this maximum, it will be excluded from the correlation analysis."
        },
        "conversionSteps" : {
          "type" : "array",
          "description" : "Conversion steps list",
          "items" : {
            "$ref" : "#/definitions/ConversionStep"
          }
        }
      }
    },
    "UnitCategory" : {
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "Category name"
        }
      }
    },
    "User" : {
      "required" : [ "administrator", "displayName", "email", "id", "loginName", "token", "wpId" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "User id"
        },
        "wpId" : {
          "type" : "integer",
          "description" : "Wordpress user id"
        },
        "displayName" : {
          "type" : "string",
          "description" : "User display name"
        },
        "loginName" : {
          "type" : "string",
          "description" : "User login name"
        },
        "email" : {
          "type" : "string",
          "description" : "User email"
        },
        "token" : {
          "type" : "string",
          "description" : "User token"
        },
        "administrator" : {
          "type" : "boolean",
          "description" : "Is user administrator"
        }
      }
    },
    "UserTag" : {
      "required" : [ "conversionFactor", "tagVariableId", "taggedVariableId" ],
      "properties" : {
        "taggedVariableId" : {
          "type" : "integer",
          "description" : "This is the id of the variable being tagged with an ingredient or something."
        },
        "tagVariableId" : {
          "type" : "integer",
          "description" : "This is the id of the ingredient variable whose value is determined based on the value of the tagged variable."
        },
        "conversionFactor" : {
          "type" : "number",
          "description" : "Number by which we multiply the tagged variable value to obtain the tag variable (ingredient) value"
        }
      }
    },
    "UserTokenRequest" : {
      "type" : "object",
      "required" : [ "organizationAccessToken" ],
      "properties" : {
        "user" : {
          "$ref" : "#/definitions/UserTokenRequestInnerUserField"
        },
        "organizationAccessToken" : {
          "type" : "string",
          "description" : "Organization Access token"
        }
      }
    },
    "UserTokenSuccessfulResponse" : {
      "type" : "object",
      "required" : [ "code", "message", "user" ],
      "properties" : {
        "code" : {
          "type" : "integer",
          "description" : "Status code"
        },
        "message" : {
          "type" : "string",
          "description" : "Message"
        },
        "user" : {
          "$ref" : "#/definitions/UserTokenSuccessfulResponseInnerUserField"
        }
      }
    },
    "UserTokenFailedResponse" : {
      "type" : "object",
      "required" : [ "code", "message", "success" ],
      "properties" : {
        "code" : {
          "type" : "integer",
          "description" : "Status code"
        },
        "message" : {
          "type" : "string",
          "description" : "Message"
        },
        "success" : {
          "type" : "boolean"
        }
      }
    },
    "UserTokenRequestInnerUserField" : {
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "WordPress user ID"
        }
      }
    },
    "UserTokenSuccessfulResponseInnerUserField" : {
      "required" : [ "access_token", "id" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "WordPress user ID"
        },
        "access_token" : {
          "type" : "string",
          "description" : "User token"
        }
      }
    },
    "UserVariableRelationship" : {
      "required" : [ "confidence_level", "confidence_score", "direction", "duration_of_action", "outcome_variableId", "predictor_unit_id", "predictor_variableId", "sinn_rank", "strength_level", "strength_score", "value_predicting_high_outcome", "value_predicting_low_outcome" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "id"
        },
        "confidence_level" : {
          "type" : "string",
          "description" : "Our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors"
        },
        "confidence_score" : {
          "type" : "number",
          "format" : "float",
          "description" : "A quantitative representation of our confidence that a consistent predictive relationship exists based on the amount of evidence, reproducibility, and other factors"
        },
        "direction" : {
          "type" : "string",
          "description" : "Direction is positive if higher predictor values generally precede higher outcome values. Direction is negative if higher predictor values generally precede lower outcome values."
        },
        "duration_of_action" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay."
        },
        "error_message" : {
          "type" : "string",
          "description" : "error_message"
        },
        "onset_delay" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the “onset delay”. For example, the “onset delay” between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes."
        },
        "outcome_variableId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Variable ID for the outcome variable"
        },
        "predictor_variableId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Variable ID for the predictor variable"
        },
        "predictor_unit_id" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID for default unit of the predictor variable"
        },
        "sinn_rank" : {
          "type" : "number",
          "format" : "float",
          "description" : "A value representative of the relevance of this predictor relative to other predictors of this outcome.  Usually used for relevancy sorting."
        },
        "strength_level" : {
          "type" : "string",
          "description" : "Can be weak, medium, or strong based on the size of the effect which the predictor appears to have on the outcome relative to other variable relationship strength scores."
        },
        "strength_score" : {
          "type" : "number",
          "format" : "float",
          "description" : "A value represented to the size of the effect which the predictor appears to have on the outcome."
        },
        "userId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "userId"
        },
        "vote" : {
          "type" : "string",
          "description" : "vote"
        },
        "value_predicting_high_outcome" : {
          "type" : "number",
          "format" : "float",
          "description" : "Value for the predictor variable (in it's default unit) which typically precedes an above average outcome value"
        },
        "value_predicting_low_outcome" : {
          "type" : "number",
          "format" : "float",
          "description" : "Value for the predictor variable (in it's default unit) which typically precedes a below average outcome value"
        }
      }
    },
    "Update" : {
      "required" : [ "connectorId", "message", "numberOfMeasurements", "success", "userId" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "id"
        },
        "userId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "userId"
        },
        "connectorId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "connectorId"
        },
        "numberOfMeasurements" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "numberOfMeasurements"
        },
        "success" : {
          "type" : "boolean",
          "description" : "success"
        },
        "message" : {
          "type" : "string",
          "description" : "message"
        },
        "createdAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record was first created. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        },
        "updatedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record in the database was last updated. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        }
      }
    },
    "UserVariable" : {
      "required" : [ "variableId" ],
      "properties" : {
        "parentId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of the parent variable if this variable has any parent"
        },
        "userId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "User ID"
        },
        "clientId" : {
          "type" : "string",
          "description" : "clientId"
        },
        "variableId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of variable"
        },
        "defaultUnitId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of unit to use for this variable"
        },
        "minimumAllowedValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "The minimum allowed value for measurements. While you can record a value below this minimum, it will be excluded from the correlation analysis."
        },
        "maximumAllowedValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "The maximum allowed value for measurements. While you can record a value above this maximum, it will be excluded from the correlation analysis."
        },
        "fillingValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "When it comes to analysis to determine the effects of this variable, knowing when it did not occur is as important as knowing when it did occur. For example, if you are tracking a medication, it is important to know when you did not take it, but you do not have to log zero values for all the days when you haven't taken it. Hence, you can specify a filling value (typically 0) to insert whenever data is missing."
        },
        "joinWith" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The Variable this Variable should be joined with. If the variable is joined with some other variable then it is not shown to user in the list of variables"
        },
        "onsetDelay" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the “onset delay”. For example, the “onset delay” between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes."
        },
        "durationOfAction" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay."
        },
        "variableCategoryId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of variable category"
        },
        "updated" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "updated"
        },
        "public" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Is variable public"
        },
        "causeOnly" : {
          "type" : "boolean",
          "description" : "A value of 1 indicates that this variable is generally a cause in a causal relationship.  An example of a causeOnly variable would be a variable such as Cloud Cover which would generally not be influenced by the behaviour of the user"
        },
        "fillingType" : {
          "type" : "string",
          "description" : "0 -> No filling, 1 -> Use filling-value"
        },
        "numberOfMeasurements" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of measurements"
        },
        "numberOfProcessedDailyMeasurements" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of processed measurements"
        },
        "measurementsAtLastAnalysis" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of measurements at last analysis"
        },
        "lastUnitId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of last Unit"
        },
        "lastOriginalUnitId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of last original Unit"
        },
        "lastValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "Last Value"
        },
        "lastOriginalValue" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Last original value which is stored"
        },
        "numberOfCorrelations" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of correlations for this variable"
        },
        "status" : {
          "type" : "string",
          "description" : "status"
        },
        "errorMessage" : {
          "type" : "string",
          "description" : "error_message"
        },
        "lastSuccessfulUpdateTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When this variable or its settings were last updated"
        },
        "standard_deviation" : {
          "type" : "number",
          "format" : "float",
          "description" : "Standard deviation"
        },
        "variance" : {
          "type" : "number",
          "format" : "float",
          "description" : "Variance"
        },
        "minimumRecordedValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "Minimum recorded value of this variable"
        },
        "maximumRecordedDailyValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "Maximum recorded daily value of this variable"
        },
        "mean" : {
          "type" : "number",
          "format" : "float",
          "description" : "Mean"
        },
        "median" : {
          "type" : "number",
          "format" : "float",
          "description" : "Median"
        },
        "mostCommonUnitId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Most common Unit ID"
        },
        "mostCommonValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "Most common value"
        },
        "numberOfUniqueDailyValues" : {
          "type" : "number",
          "format" : "float",
          "description" : "Number of unique daily values"
        },
        "numberOfChanges" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Number of changes"
        },
        "skewness" : {
          "type" : "number",
          "format" : "float",
          "description" : "Skewness"
        },
        "kurtosis" : {
          "type" : "number",
          "format" : "float",
          "description" : "Kurtosis"
        },
        "latitude" : {
          "type" : "number",
          "format" : "float",
          "description" : "Latitude"
        },
        "longitude" : {
          "type" : "number",
          "format" : "float",
          "description" : "Longitude"
        },
        "location" : {
          "type" : "string",
          "description" : "Location"
        },
        "experimentStartTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Earliest measurement start_time to be used in analysis. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        },
        "experimentEndTime" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "Latest measurement start_time to be used in analysis. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        },
        "createdAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record was first created. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        },
        "updatedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record in the database was last updated. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        },
        "outcome" : {
          "type" : "boolean",
          "description" : "Outcome variables (those with `outcome` == 1) are variables for which a human would generally want to identify the influencing factors. These include symptoms of illness, physique, mood, cognitive performance, etc.  Generally correlation calculations are only performed on outcome variables"
        },
        "sources" : {
          "type" : "string",
          "description" : "Comma-separated list of source names to limit variables to those sources"
        },
        "earliestSourceTime" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Earliest source time"
        },
        "latestSourceTime" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Latest source time"
        },
        "earliestMeasurementTime" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Earliest measurement time"
        },
        "latestMeasurementTime" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Latest measurement time"
        },
        "earliestFillingTime" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Earliest filling time"
        },
        "latestFillingTime" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Latest filling time"
        },
        "imageUrl" : {
          "type" : "string",
          "description" : ""
        },
        "ionIcon" : {
          "type" : "string",
          "description" : ""
        }
      }
    },
    "UserVariables" : {
      "required" : [ "user", "variableId" ],
      "properties" : {
        "user" : {
          "type" : "integer",
          "description" : "User ID"
        },
        "variableId" : {
          "type" : "integer",
          "description" : "Common variable id"
        },
        "durationOfAction" : {
          "type" : "integer",
          "description" : "The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay."
        },
        "fillingValue" : {
          "type" : "integer",
          "description" : "When it comes to analysis to determine the effects of this variable, knowing when it did not occur is as important as knowing when it did occur. For example, if you are tracking a medication, it is important to know when you did not take it, but you do not have to log zero values for all the days when you haven't taken it. Hence, you can specify a filling value (typically 0) to insert whenever data is missing."
        },
        "joinWith" : {
          "type" : "string",
          "description" : "joinWith"
        },
        "maximumAllowedValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "The maximum allowed value for measurements. While you can record a value above this maximum, it will be excluded from the correlation analysis."
        },
        "minimumAllowedValue" : {
          "type" : "number",
          "format" : "float",
          "description" : "The minimum allowed value for measurements. While you can record a value below this minimum, it will be excluded from the correlation analysis."
        },
        "onsetDelay" : {
          "type" : "integer",
          "description" : "onsetDelay"
        },
        "experimentStartTime" : {
          "type" : "string",
          "description" : "Earliest measurement startTime that should be used in analysis. For instance, the date when you started tracking something.  Helpful in determining when to start 0 filling since we can assume the absence of a treatment measurement, for instance, indicates that the treatment was not applied rathter than simply not recorded.  Uses ISO string format"
        },
        "experimentEndTime" : {
          "type" : "string",
          "description" : "Latest measurement startTime that should be used in analysis. For instance, the date when you stopped tracking something.  Helpful in determining when to stop 0 filling since we can assume the absence of a treatment measurement, for instance, indicates that the treatment was not applied rathter than simply not recorded.   Uses ISO string format"
        },
        "alias" : {
          "type" : "string",
          "description" : "User-defined display alias for variable name"
        }
      }
    },
    "ValueObject" : {
      "required" : [ "timestamp", "value" ],
      "properties" : {
        "timestamp" : {
          "type" : "integer",
          "format" : "int64",
          "description" : "Timestamp for the measurement event in epoch time (unixtime)"
        },
        "value" : {
          "type" : "number",
          "format" : "double",
          "description" : "Measurement value"
        },
        "note" : {
          "type" : "string",
          "description" : "Optional note to include with the measurement"
        }
      }
    },
    "Variable" : {
      "required" : [ "abbreviatedUnitId", "category", "causeOnly", "combinationOperation", "durationOfAction", "earliestMeasurementTime", "fillingValue", "joinWith", "joinedVariables", "lastSource", "lastUnit", "lastValue", "latestMeasurementTime", "maximumAllowedValue", "minimumAllowedValue", "mostCommonUnit", "mostCommonValue", "name", "numberOfCorrelations", "numberOfRawMeasurements", "onsetDelay", "outcome", "parent", "rawMeasurementsAtLastAnalysis", "sources", "subVariables", "unitAbbreviatedName", "updated" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "description" : "Variable ID"
        },
        "name" : {
          "type" : "string",
          "description" : "User-defined variable display name."
        },
        "category" : {
          "type" : "string",
          "description" : "Variable category like Mood, Sleep, Physical Activity, Treatment, Symptom, etc."
        },
        "unitAbbreviatedName" : {
          "type" : "string",
          "description" : "Abbreviated name of the default unit for the variable"
        },
        "abbreviatedUnitId" : {
          "type" : "integer",
          "description" : "Id of the default unit for the variable"
        },
        "sources" : {
          "type" : "string",
          "description" : "Comma-separated list of source names to limit variables to those sources"
        },
        "minimumAllowedValue" : {
          "type" : "number",
          "format" : "double",
          "description" : "The minimum allowed value for measurements. While you can record a value below this minimum, it will be excluded from the correlation analysis."
        },
        "maximumAllowedValue" : {
          "type" : "number",
          "format" : "double",
          "description" : "The maximum allowed value for measurements. While you can record a value above this maximum, it will be excluded from the correlation analysis."
        },
        "combinationOperation" : {
          "type" : "string",
          "description" : "Way to aggregate measurements over time. Options are \"MEAN\" or \"SUM\". SUM should be used for things like minutes of exercise.  If you use MEAN for exercise, then a person might exercise more minutes in one day but add separate measurements that were smaller.  So when we are doing correlational analysis, we would think that the person exercised less that day even though they exercised more.  Conversely, we must use MEAN for things such as ratings which cannot be SUMMED.",
          "enum" : [ "MEAN", "SUM" ]
        },
        "fillingValue" : {
          "type" : "number",
          "format" : "double",
          "description" : "When it comes to analysis to determine the effects of this variable, knowing when it did not occur is as important as knowing when it did occur. For example, if you are tracking a medication, it is important to know when you did not take it, but you do not have to log zero values for all the days when you haven't taken it. Hence, you can specify a filling value (typically 0) to insert whenever data is missing."
        },
        "joinWith" : {
          "type" : "string",
          "description" : "The Variable this Variable should be joined with. If the variable is joined with some other variable then it is not shown to user in the list of variables."
        },
        "joinedVariables" : {
          "type" : "array",
          "description" : "Array of Variables that are joined with this Variable",
          "items" : {
            "$ref" : "#/definitions/Variable"
          }
        },
        "parent" : {
          "type" : "integer",
          "description" : "Id of the parent variable if this variable has any parent"
        },
        "subVariables" : {
          "type" : "array",
          "description" : "Array of Variables that are sub variables to this Variable",
          "items" : {
            "$ref" : "#/definitions/Variable"
          }
        },
        "onsetDelay" : {
          "type" : "integer",
          "description" : "The amount of time in seconds that elapses after the predictor/stimulus event before the outcome as perceived by a self-tracker is known as the “onset delay”. For example, the “onset delay” between the time a person takes an aspirin (predictor/stimulus event) and the time a person perceives a change in their headache severity (outcome) is approximately 30 minutes."
        },
        "durationOfAction" : {
          "type" : "integer",
          "description" : "The amount of time over which a predictor/stimulus event can exert an observable influence on an outcome variable’s value. For instance, aspirin (stimulus/predictor) typically decreases headache severity for approximately four hours (duration of action) following the onset delay."
        },
        "earliestMeasurementTime" : {
          "type" : "integer",
          "description" : "Earliest measurement time"
        },
        "latestMeasurementTime" : {
          "type" : "integer",
          "description" : "Latest measurement time"
        },
        "updated" : {
          "type" : "integer",
          "description" : "When this variable or its settings were last updated"
        },
        "causeOnly" : {
          "type" : "integer",
          "description" : "A value of 1 indicates that this variable is generally a cause in a causal relationship.  An example of a causeOnly variable would be a variable such as Cloud Cover which would generally not be influenced by the behaviour of the user."
        },
        "numberOfCorrelations" : {
          "type" : "integer",
          "description" : "Number of correlations"
        },
        "outcome" : {
          "type" : "integer",
          "description" : "Outcome variables (those with `outcome` == 1) are variables for which a human would generally want to identify the influencing factors. These include symptoms of illness, physique, mood, cognitive performance, etc.  Generally correlation calculations are only performed on outcome variables."
        },
        "rawMeasurementsAtLastAnalysis" : {
          "type" : "integer",
          "description" : "The number of measurements that a given user had for this variable the last time a correlation calculation was performed. Generally correlation values are only updated once the current number of measurements for a variable is more than 10% greater than the rawMeasurementsAtLastAnalysis.  This avoids a computationally-demanding recalculation when there's not enough new data to make a significant difference in the correlation."
        },
        "numberOfRawMeasurements" : {
          "type" : "integer",
          "description" : "Number of measurements"
        },
        "lastUnit" : {
          "type" : "string",
          "description" : "Last unit"
        },
        "lastValue" : {
          "type" : "integer",
          "description" : "Last value"
        },
        "mostCommonValue" : {
          "type" : "integer",
          "description" : "Most common value"
        },
        "mostCommonUnit" : {
          "type" : "string",
          "description" : "Most common unit"
        },
        "lastSource" : {
          "type" : "integer",
          "description" : "Last source"
        },
        "imageUrl" : {
          "type" : "string",
          "description" : ""
        },
        "ionIcon" : {
          "type" : "string",
          "description" : ""
        }
      }
    },
    "VariableCategory" : {
      "required" : [ "name" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "Category name"
        }
      }
    },
    "VariableNew" : {
      "required" : [ "category", "combinationOperation", "name", "parent", "unit" ],
      "properties" : {
        "name" : {
          "type" : "string",
          "description" : "User-defined variable display name."
        },
        "category" : {
          "type" : "string",
          "description" : "Variable category like Mood, Sleep, Physical Activity, Treatment, Symptom, etc."
        },
        "unit" : {
          "type" : "string",
          "description" : "Abbreviated name of the default unit for the variable"
        },
        "combinationOperation" : {
          "type" : "string",
          "description" : "Way to aggregate measurements over time. Options are \"MEAN\" or \"SUM\". SUM should be used for things like minutes of exercise.  If you use MEAN for exercise, then a person might exercise more minutes in one day but add separate measurements that were smaller.  So when we are doing correlational analysis, we would think that the person exercised less that day even though they exercised more.  Conversely, we must use MEAN for things such as ratings which cannot be SUMMED.",
          "enum" : [ "MEAN", "SUM" ]
        },
        "parent" : {
          "type" : "string",
          "description" : "Parent"
        }
      }
    },
    "VariablesNew" : {
      "type" : "array",
      "description" : "New variables",
      "items" : {
        "$ref" : "#/definitions/VariableNew"
      }
    },
    "VoteDelete" : {
      "required" : [ "cause", "effect" ],
      "properties" : {
        "cause" : {
          "type" : "string",
          "description" : "Cause variable name for the correlation to which the vote pertains"
        },
        "effect" : {
          "type" : "string",
          "description" : "Effect variable name for the correlation to which the vote pertains"
        }
      }
    },
    "Vote" : {
      "required" : [ "causeId", "clientId", "effectId", "userId", "value" ],
      "properties" : {
        "id" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "id"
        },
        "clientId" : {
          "type" : "string",
          "description" : "clientId"
        },
        "userId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of User"
        },
        "causeId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of the predictor variable"
        },
        "effectId" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "ID of effect variable"
        },
        "value" : {
          "type" : "integer",
          "format" : "int32",
          "description" : "Value of Vote"
        },
        "createdAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record was first created. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        },
        "updatedAt" : {
          "type" : "string",
          "format" : "date-time",
          "description" : "When the record in the database was last updated. Use UTC ISO 8601 \"YYYY-MM-DDThh:mm:ss\"  datetime format"
        }
      }
    },
    "inline_response_200" : {
      "properties" : {
        "success" : {
          "type" : "boolean"
        },
        "data" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/TrackingReminder"
          }
        }
      }
    },
    "inline_response_200_1" : {
      "properties" : {
        "success" : {
          "type" : "boolean"
        },
        "data" : {
          "$ref" : "#/definitions/TrackingReminder"
        }
      }
    },
    "inline_response_200_2" : {
      "properties" : {
        "success" : {
          "type" : "boolean"
        },
        "data" : {
          "type" : "array",
          "items" : {
            "$ref" : "#/definitions/TrackingReminderNotification"
          }
        }
      }
    }
  }
}